gr.match
fx
x
grl
grl[1]
grl=c(grl[1], grl[1])
grl
findOverlaps(x, unlist(grl))
x
a=findOverlaps(x, unlist(grl))
a
a[1]
a[1]$subjectHits
class(a[1])
a[1][1]
a[1]
a[1]$queryHits
Hits
a$distance
 a
queryHits(fo)
queryHits(a)
subjectHits(a)
x
class(subjectHits(a))
subjectHits(a)[1]
map(queryHits, subjectHits)
map
dt=data.table(queryHits, subjectHits)
dt
dt=data.table(queryHits=queryHits[1:length(queryHits)], subjectHits[1:length(subjectHits)])
length(queryHits)
queryHits
a
 queryHits(a)
q= queryHits(a)
s= subjectHits(a)
dt=data.table(q=queryHits[1:length(q)], subjectHits[1:length(s)])
dt=data.table(q=queryHits(q), subjectHits(s))
dt=data.table(q=queryHits(q), s=subjectHits(s))
queryHits(q)
dt=data.table(q=q, s=s)
dt
dt[q==1, s]
dt[q==2, s]
dt[s==1, q]
dt[s==2, q]
1 %in q
1 %in% q
remove[seq_along(q) %%2 !=0]
q
sequ_along(q)
seq_along(q)
remove[seq_along(q) %%2>]
remove[seq_along(q) %%2>0]
q[seq_along(q)%%2>0]
q
seq_alongq%%2>0
seq_along(q)%%2>0
%%
dt
 3%%2
7%%2
6%%2
dt[q%%2==1, q]
unique(dt[q%%2==1, q])
dt
dt[s==3, q]
dt[q==3, s]
edges
junc1
gg$edges %&% junc1
n
n
junc1
gg$edges
Q
gg$edges %&% junc1
n
n
x
paste(x[from], x[tp])
x[, from]
x
x[from]
x$dt
x$dt[, from]
x
x[from==3]
x[, from]
x
Q
x[, from]
gg$edges %&% junc1
n
n
n
n
n
n
overlaps.dt
overlaps
Q
load_all()
load_all()
load_all()
gg=gGraph$new(nodes=nodes1, edges=edges)
gg$edges %&% junc1
n
n
n
n
n
n
overlaps.dt
overlaps
juncs
y$juncs
Q
load_all()
gg$edges %&% junc1
n
n
n
n
n
overlaps
verlaps.dt
n
overlaps.dt
overlaps
unlist(juncs)
unlist(y$juncs)
n
ods
odds
overlaps.dt
dt
Q
load_all()
gg$edges %&% junc1
n
n
n
n
n
n
n
gg$edges %&% junc1
n
n
n
n
n
n
overlaps.dt
unique(overlaps.dt)
overlaps.dt[s%%==1, s]
overlaps.dt[s%%2==1, s]
overlaps.dt[s%%2==0, s]
dt
overlaps
overlaps.dt
overlaps.dt[subject%%2==1, subject]
n
load_all()
gg$edges %&% junc1
n
n
n
n
n
n
n
match
a= 4,3
a= "4,3"
b="3,4
"
a
b
gg$edges %&% junc1
n
n
n
n
juncs
unlist juncs
unlist(juncs)
unlist(y$juncs)
Q
nodes1
gg$edges
gg$edges$junctions
gg$edges$junctions[4]
gg$edges$junctions[5]
match
a=(4,5)
a=c(4,5)
b=c(6, 7(
)
)
b=c(6, 7)
union(a, b)
union(a, b)
a=union(a, b)
intersect(a,b)
d=c(b, c(3,8))
intersect(a, b)
a
list(a, b)
9=list(a, b)
h=list(a, b)
intersect(h, a)
h
unlist(h)
gg$edges
gg$edges$junctions
gr1=c(GRanges("1", IRanges(250, 350), "-"), GRanges("1", IRanges(130, 202), "+"))
gr2=c(GRanges("1", IRanges(250, 350), "+"), GRanges("1", IRanges(130, 202), "-"))
gr3=c(GRanges("1", IRanges(600, 700), "+"), GRanges("1", IRanges(900, 1000), "-"))
grl=GRangesList(gr1, gr2, gr3)
grl
junc1=Junction$new(grl)
junc1
gg$edges %&% junc1
n
n
n
n
n
overlaps
juncs
Q
juncs1
juncs
junc1=Junction$new(grl)
junc1
gg$edges %&% junc1
n
n
n
n
juncs
y$juncs
n
overlaps
juncs
unlist(juncs)
n
overlaps.dt
n
gg$edges %&% juncs1
gg$edges %&% juncs
gg$edges %&% junc1
n
n
n
n
n
overlaps
n
overlaps.dt
overlaps.dt[subject%%2==1, subject]
uniqueoverlaps.dt[subject%%2==1, subject]
unique(overlaps.dt[subject%%2==1, subject])
Q
load_all()
gg$edges %&% junc1
n
n
n
n
n
n
overlaps.dt
n
odds
n
load_all()
 gg$edges %&% junc1
n
n
n
n
n
n
n
n
Q
load_all()
gg$edges %&% junc1
n
n
n
n
n
n
n
n
n
n
n
n
n
query1
query2
union(query1, query2)
Q
load_all()
load_all()
ra.overlaps
gg$edges
gg$edges$junctions
gg$edges$junctions$juncs
a=gg$edges$junctions$juncs
 junc
junc1
ra.overlaps(a, junc1)
ra.overlaps(a, junc1$juncs)
a
juncs1$juncs
junc1$juncs
olaps=ra.overlaps(a, junc1$juncs)
class(olaps)
olaps[1]
olaps[2]
olaps[1][1]
olaps[1][2]
load_all()
gg$edges %&% junc1
n
n
n
n
n
overlaps
Q
olaps
olaps[ra1.ix]
olaps[,"ra1.ix]
"
]
olaps[,"ra1.ix"]
load_all()
gg$edges %&% junc1
n
n
n
n
n
x$juncs[olaps[, "ra1.ix"]]
x$juncs
x
x$junctions$juncs[olaps[,"ra1.ix"]]
Q
load_all()
gg$edges %&% junc1
junc1
gg$edges
load_all()
gg$edges %&% junc1
load_all()
gg$edges %&% junc1
n
n
n
n
n
overlaps
juncs
edges[1]
x[1]
Q
load_all()
gg$edges %&% junc1
n
n
n
n
n
n
gg$edges %&% junc1
n
n
n
n
n
overlaps
overlaps[, "ra1.ix"]
x[overlaps[, "ra1.ix"]]
overlaps
Q
load_all()
olaps
overlaps
gg$edges %&% junc1
n
n
n
n
n
overlaps
x[overlaps[, "ra1.ix"]]
overlaps[, "ra1.ix"]
e=overlaps[, "ra1.ix"]
x[e]
e
x[1]
x[c(1, 2]]
x[c(1, 2)]
overlaps[, "ra1.ix"]
e=overlaps[, "ra1.ix"]
x
x[e]
e
x
x[e]
names
names()
ls
ls()
gr
e
x[e]
x["e"]
x
x$dt
x$dt[e]
x[1]
x
x$graph
x$graph$nodes
a=x$dt[e]
a
x$graph$nodes$gr
n=gGraph$new(nodes=x$graph$nodes$gr, edges=a)
convertEdges(a)
convertEdges
n
gg$edges%&%junc1
n
a=x$graph$nodes$gr
a
n
n
n
n
e=x$dt[overlaps[,"ra1.ix"]]
e
convertEdges(e)
a
x$convertEdges
a
ge
g
e
x
x[e]
x$dt
Q
load_all()

g1 = gGraph$new(jabba=jab)
js1 = g1$json <- "HCC1143.js"
0
0
load_all()
devools::load_all()
detools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
options(error = recover)
options(warn = 3)
tile = gr.tile(hg_seqlengths(), 1e6)
devtools::load_all()
4
i
i
pkg
c
process_imports(pkg)
load_imports(pkg)
Q
options(warn = 1)
devtools::load_all()
devtools::load_all()
options(warn = 3)
devtools::load_all()
names
handler
handlers
c
c
ls()
ls()
package
i
5
cond
2
process_imports
process_imports
package
pkg$ame
pkg$name
y
    vI <- ("tools" %:::% ".split_description")(("tools" %:::% 
        ".read_description")(file.path(pkg$path, "DESCRIPTION")))$Imports
    nsInfo <- parse_ns_file(pkg)
    ns <- ns_env(pkg)
    lib.loc <- NULL
nsInfo$importss
nsInfo$imports
i = nsInfo$imports[1]
process_imports
is.character(i)
 (!is.null(i$except)) 
namespaceImportFrom(ns, loadNamespace(j <- i[[1L]], 
 namespaceImportFrom(ns, loadNamespace(j <- i[[1L]], 
            c(lib.loc, .libPaths()), versionCheck = vI[[j]]), 
            i[[2L]], from = package)
namespaceImportFrom(ns, loadNamespace(j <- i[[1L]], 
            c(lib.loc, .libPaths()), versionCheck = vI[[j]]), 
            i[[2L]], from = package)
j
Q
0
dir()
setwd('..')
devtools::load_all()
process_imports
    for (i in nsInfo$imports) tryCatch(error = warning, {
        if (is.character(i)) 
            namespaceImport(ns, loadNamespace(i, c(lib.loc, .libPaths()), 
                versionCheck = vI[[i]]), from = package)
        else if (!is.null(i$except)) 
            namespaceImport(ns, loadNamespace(j <- i[[1L]], c(lib.loc, 
                .libPaths()), versionCheck = vI[[j]]), from = package, 
                except = i$except)
        else namespaceImportFrom(ns, loadNamespace(j <- i[[1L]], 
            c(lib.loc, .libPaths()), versionCheck = vI[[j]]), 
            i[[2L]], from = package)
    })
i
    for (imp in nsInfo$importClasses) tryCatch(error = warning, 
        namespaceImportClasses(ns, loadNamespace(j <- imp[[1L]], 
            c(lib.loc, .libPaths()), versionCheck = vI[[j]]), 
            imp[[2L]], from = package))
    for (imp in nsInfo$importMethods) tryCatch(error = warning, 
        namespaceImportMethods(ns, loadNamespace(j <- imp[[1L]], 
            c(lib.loc, .libPaths()), versionCheck = vI[[j]]), 
            imp[[2L]], from = package))
imp
    package <- pkg$name
    vI <- ("tools" %:::% ".split_description")(("tools" %:::% 
        ".read_description")(file.path(pkg$path, "DESCRIPTION")))$Imports
    nsInfo <- parse_ns_file(pkg)
    ns <- ns_env(pkg)
    lib.loc <- NULL
    for (i in nsInfo$imports) tryCatch(error = warning, {
        if (is.character(i)) 
            namespaceImport(ns, loadNamespace(i, c(lib.loc, .libPaths()), 
                versionCheck = vI[[i]]), from = package)
        else if (!is.null(i$except)) 
            namespaceImport(ns, loadNamespace(j <- i[[1L]], c(lib.loc, 
                .libPaths()), versionCheck = vI[[j]]), from = package, 
                except = i$except)
        else namespaceImportFrom(ns, loadNamespace(j <- i[[1L]], 
            c(lib.loc, .libPaths()), versionCheck = vI[[j]]), 
            i[[2L]], from = package)
    })
    for (imp in nsInfo$importClasses) tryCatch(error = warning, 
        namespaceImportClasses(ns, loadNamespace(j <- imp[[1L]], 
            c(lib.loc, .libPaths()), versionCheck = vI[[j]]), 
            imp[[2L]], from = package))
    for (imp in nsInfo$importMethods) tryCatch(error = warning, 
        namespaceImportMethods(ns, loadNamespace(j <- imp[[1L]], 
            c(lib.loc, .libPaths()), versionCheck = vI[[j]]), 
            imp[[2L]], from = package))
c
process_imports(pkg)
Q
document()
devtools::document()
0
options(Warn = 1)
0
fuckr()
library(skitools)
fuckr()
options(warn = 1)
fuckr()
library(skitools)
0
0
0
devtools::load_all()
0
fuckr()
cds
cds
Q
ddj = c(ggj, gg.cds)$disjoin()
c
ddjs = ddj$clone()$simplify(by = 'cn')
finaledges
final.edges
unique(final.edges, by = .(n1, n2, n1.side, n2.side))
unique(final.edges, by = c("n1", "n2", "n1.side", "n2.side"))
c
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
w2$disjoin(gr)
c
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
c
setkeyv(sedgesdt, c('from', 'to'))
sedgesdt[.(pedge$from, pedge$to), sedge.id]
sedgesdt
pedge
dim(pedge)
sedgesdt[.(pedge$from, pedge$to), sedge.id]
sedgesdt[.(pedge$from, pedge$to), ]
dim(sedgesdt[.(pedge$from, pedge$to), ])
dim(pedge)
dim(sedgesdt[.(pedge$from, pedge$to), sedge.id])
length(sedgesdt[.(pedge$from, pedge$to), sedge.id])
length(sedgesdt[.(pedge$from, pedge$to), sedge.id])
c
w2$disjoin(gr)
c
w2$disjoin(gr)
sedgesdt[.(pedge$from, pedge$to), sedge.id]
dim(pedges)
dim(pedge)
dim9sedgesdt[.(pedge$from, pedge$to), ])
dim(sedgesdt[.(pedge$from, pedge$to), ])
length(sedgesdt[.(pedge$from, pedge$to), sedge.id])
Q
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
c
sedgesdt[.(pedge$from, pedge$to), sedge.id]
c
w2$disjoin(gr)
w2$disjoin(gr)
Q
w2$disjoin(gr)
Q
w2 = gWalk$new(grl = grl, disjoin = TRUE)
c
Q
Q
c
pedge
c
length(pedge$sedge.id )
length(sedgesdt[.(pedge$from, pedge$to), sedge.id])
dim(sedgesdt[.(pedge$from, pedge$to), sedge.id)
dim(sedgesdt[.(pedge$from, pedge$to), sedge.id])
di(sedgesdt[.(pedge$from, pedge$to), sedge.id])
dim(sedgesdt[.(pedge$from, pedge$to), sedge.id])
dim(sedgesdt[.(pedge$from, pedge$to), ])
fuck = sedgesdt[.(pedge$from, pedge$to), ]
ix = duplicated(fuck, by = c("from", "to"))
fuck[ix, ][1,]
setkeyv(fuck, c('from', 'to'))
shite = fuck[ix, ][1,]
fuck[shite[, .(from, to)], ]
W
Q
c
dim(tmp)
length(pedge$sedge.id )
length(tmp$sedge.id)
tmp
sedgesdt
dim(sedgesdt)
sedgesdt
Q
w2$disjoin(gr)
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
final.edges
dim(final.edges)
dim(final.edges)
final.edges[n1>n2, ]
final.edges[n1>=n2, ]
final.edges[n1!=n2, ]
Q
dim(final.edges)
dim(final.edges)
dim(final.edges)
final.edges
dim(final.edges)
dim(final.edges)
Q
dim(final.edges)
dim(final.edges)
dim(final.edges)
Q
Q
w2[1]
fuckr()
w2[1]
private$pmeta
>private$pmeta[.(abs(i)), ]
private$pmeta[.(abs(i)), ]
key(private$pmeta)
Q
w2 = gWalk$new(grl = grl, disjoin = TRUE)
c
w2$dt
w[1]
w2[1]
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
w2[1]
0
w2$graph
w2$graph$gt
stack.gap
private$pmeta
private$pmeta$y.field
ss$cn
Q
ppdf(plot(c(w2$graph$gt, w2[1]$gt), w2[1]$footprint+1e6))
w2 = gWalk$new(grl = grl, disjoin = TRUE)
source('R/utils.R');
w2 = gWalk$new(grl = grl, disjoin = TRUE)
w2$simplify()
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
0
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
0
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
w2 = gWalk$new(grl = grl, disjoin = TRUE)
w2$simplify()
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
ggj = gGraph$new(jab = jab)
ggj$walks
ggj$walks()
Q
ggj$edges[type == 'ALT', ]
ggj$edges[type == 'ALT']
ggj$edges[type == 'ALT'][1]$nodes
fuckr()
ggj$edges[type == 'ALT'][1]
ggj$edges[type == 'ALT'][1]$nodes
ggj$edges[type == 'ALT'][1]$left
ggj$edges[type == 'ALT'][1]$right
ggj$edges[type == 'ALT'][1]$nodes
fuckr()
ggj$edges[type == 'ALT'][1]$nodes
union(ggj$edges[type == 'ALT'][1], ggj$edges[type == 'ALT'][1])
union.gEdge(ggj$edges[type == 'ALT'][1], ggj$edges[type == 'ALT'][1])
unionggj$edges[type == 'ALT'][1], ggj$edges[type == 'ALT'][1])
union(ggj$edges[type == 'ALT'][1], ggj$edges[type == 'ALT'][1])
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
union(ggj$edges[type == 'ALT'][1], ggj$edges[type == 'ALT'][1])
load_all()
source('R/converters.R'); source('R/eventCallers.R'); source('R/gGnome.R');
ggj$edges[type == 'ALT'][1]$nodes
load_all()
ggj$edges[type == 'ALT'][1]$nodes
ggj$nodes$edges
q()

