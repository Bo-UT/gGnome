---
title: "[gGnome](https://github.com/mskilab/gGnome) Tutorial"
author: "Marcin Imielinski Laboratory"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: flatly
---

<style type="text/css">
body, td {
   font-size: 16px;
}
pre code, pre, code {
  font-size: 15px;
  color: rgb(20, 20, 20);
  white-space: pre !important;
  overflow-x: scroll !important;
  word-break: keep-all !important;
  word-wrap: initial !important;
}

h1{
  font-size: 22pt;
  }

h2{
  font-size: 20pt;
  }

h3{
  font-size: 16pt;
  }


</style>

```{r, setup,echo=FALSE,cache=TRUE}
## knitr::opts_chunk$set(collapse = TRUE)
knitr::opts_chunk$set(fig.width = 8, collapse = TRUE, cache = FALSE, warning = FALSE, results = "hide", message = FALSE)
library(gTrack)
library(rtracklayer)
library(kableExtra)
library(magrittr)
library(tidyr)
library(gGnome)
```

# Applications
## Classifying SV events
There are many mutagenesis pathways producing various patterns of SVs in the cancer genomes. By identifying the specific motif that are recurrent in the cancer genoem graphs, we can classify subgraphs that satisfy the set of criteria corresponding to a particular class. These classes range from simple like deletions and tandem duplications, to complex like chromothripsis and breakage-fusion-bridge cycles. As of [Hadi et al, Cell 2020](https://www.biorxiv.org/content/10.1101/836296v2), we support the identification of 5 simple event and 8 complex:

* simple
    + [Deletion (del)](#deletions-and-rigma)
    + [Tandem duplication (dup)](#tandem-duplications-and-pyrgo)
    + [Inversion (inv)](#simple)
    + [Inverted duplication (invdup)](#simple)
    + [Translocations (tra)](#simple)
* complex
    + [Rigma](#deletions-and-rigma)
    + [Pyrgo](#tandem-duplications-and-pyrgo)
    + [Templated insertion chains (tic)](cp-and-tic)
    + [Chromoplexy](#cp-and-tic)
    + [Chromothripsis](#chromothripsis)
    + [Breakage-fusion-bridge cycles (bfb)](#amplicons)
    + [Double minute (dm)](#amplicons)
    + [Tyfonas](#amplicons)

For ease of use, all the callers are wrapped into a single function `events`:

```{r, events, warning = FALSE, fig.width = 8, collapse = TRUE, warning = FALSE, results = "markup", message = FALSE}
## load the graph for HCC1954
hcc1954 = gG(jabba = system.file("extdata", "hcc1954", "jabba.rds", package = "gGnome"))

## Identify all supported SV event types
hcc1954 = events(hcc1954, verbose = FALSE)

## Summary of identified events
hcc1954$meta$event[, table(type)]

## plot the locus of a BFB event
plot(hcc1954$gt, hcc1954[bfb>0]$footprint + 1e6); title("BFB in HCC1954")

## for the following examples load the CCLE models
ccle = dir(system.file("extdata", package = "gGnome"), ".+jabba.simple.rds", full = TRUE)
names(ccle) = gsub(".*gGnome/[inst/]?extdata/(.*)\\.jabba\\.simple\\.rds$", "\\1", ccle)
```

Below we describe each function in detail.

### Deletions and Rigma
When simple deletions accumulate in the same locus more than expected from a null distribution (explained below), their cluster is labeled rigma.

```{r, deletions and rigma, warning = FALSE, fig.width = 8, collapse = TRUE, cache = FALSE, warning = FALSE, results = "hide", message = FALSE}
hcc1954 = del(hcc1954)
plot(hcc1954$gt, hcc1954$meta$rigma$footprint %>% GRanges %>% streduce(5e5)); title("Rigma in HCC1954")
```

### Tandem duplications and pyrgo
Similar to deletions and rigma, when a particular genomic region attain more than expected tandem duplications, the cluster of duplications is classified as a pyrgo.

```{r, duplications and pyrgo, warning = FALSE, cache = FALSE, fig.width = 8, collapse = TRUE, cache = FALSE, warning = FALSE, results = "hide", message = FALSE}
mfe280 = gG(jabba = ccle["MFE_280"])
mfe280 = dup(mfe280)
plot(mfe280$gt, mfe280$meta$pyrgo$footprint %>% head(3) %>% GRanges %>% streduce(5e5)); title("Pyrgos in MFE-280")
```

### Chromothripsis
Chromothripsis has been a stereotypical example of complex SV event, since its inception in [Stephens et al., Cell 2011](https://doi.org/10.1016/j.cell.2010.11.055), in which it is proposed to originate from a single catastrophic shattering of a relatively focused chromosome region (e.g. arm), then randomly ligated by DNA repair pathway, resulting in high numbers of junctions clustered, and oscillating copy numbers due to the random loss/retention of DNA shards. 

```{r, chromothripsis, warning = FALSE, cache = FALSE, fig.width = 8, collapse = TRUE, cache = FALSE, warning = FALSE, results = "hide", message = FALSE}
h2081 = gG(jabba = ccle["NCI_H2081"])
h2081 = chromothripsis(h2081)
plot(h2081$gt, streduce(h2081$gr %Q% which(chromothripsis>0), 1e6)); title("Chromothripsis in NCI-H2081")
```

### Complex amplicons (bfb, dm, tyfonas)
Long has been known that genomic amplifications can drive carcinogenesis, yet the characterization of the exact structures beyond the increase in dosage are limited. Two mechanisms are well known, double minute (DM, also known as extrachromosomal circular DNA, eccDNA) and breakage-fusion-bridge cycles (BFBC). Genome graphs provides an oppurtunity to systematically differentiate and discover the spectrum of amplicon structures. In Hadi et al., Cell 2020, We describe a genome graph-derived feature space for these subgraphs that contain amplified junctions (JCN>7) and stably clustered into at least 3 classes, two of which correspond to DM and BFBC, but a third class with high numbers of junctions and high numbers of fold-back inversions, which is named *tyfonas* based on its wide reaching, extensively rearranged appearance.

The function `amp` identifies 

```{r, amplicon, warning=FALSE, fig.width = 8, collapse = TRUE, cache = FALSE, warning = FALSE, results = "hide", message = FALSE}
h526 = gG(jabba = ccle["NCI_H526"])
h526 = amp(h526)
plot(h526$gt, streduce(h526$gr %Q% which(tyfonas>0), 1e6))

hara = gG(jabba = ccle["HARA"])
hara = amp(hara)
plot(hara$gt, streduce(hara$gr %Q% which(bfb>0), 1e6))

hcc827 = gG(jabba = ccle["HCC827"])
hcc827 = amp(hcc827)
plot(hcc827$gt, streduce(hcc827$gr %Q% which(dm>0), 1e6))
```


### Chromoplexy and TICs
A series of long-range junctions (jumping over >=10Mbp on reference genome) can form a chain-like topology, when two breakends from two adjacent junctions in the chain are close enough to each other (by default <= 10 kbp).

```{r, cp and tic, warning = FALSE, cache = FALSE, fig.width = 8, collapse = TRUE, warning = FALSE, echo = TRUE, results = "hide", message = FALSE}
h2228 = gG(jabba = ccle["NCI_H2228"])
h2228 = chromoplexy(h2228)
plot(h2228$gt, h2228$edges[which(chromoplexy>0)]$shadow %>% streduce(5e6)); title("Chromoplexy in NCI-H2228")

jhos2 = gG(jabba = ccle["JHOS_2"])
jhos2 = tic(jhos2)
plot(jhos2$gt, jhos2$gr %Q% which(tic %in% head(sort(unique(tic)), 3)) %>% streduce(5e4)); title("TICs in JHOS-2")
```

### Simple
We also support identification of 3 other simple event types, namely inversion, inverted duplication, and ranslocation. Here are some examples:
```{r, others, warning = FALSE, cache = FALSE, fig.width = 8, collapse = TRUE, warning = FALSE, results = "hide", message = FALSE}
hcc1954 = simple(hcc1954)
plot(hcc1954$gt, hcc1954$edges[grepl("^INV[0-9]+$", simple)]$shadow %>% streduce(1e5)); title("Inversion in HCC1954")
plot(hcc1954$gt, hcc1954$edges[grepl("^INVDUP[0-9]+$", simple)]$shadow %>% streduce(1e5)); title("Inverted duplication in HCC1954")

h526 = simple(h526)
plot(h526$gt, h526$edges[grepl("TRA", simple)]$shadow %>% streduce(1e5))
```

### Make your own caller
Besides running our current implemented event callers, `h2228nome` serves as a generalized framework for users to write their own event callers. A general template procedure is:
- Filter the nodes/edges of interest by their marginal features, e.g. copy number, width, junction span (reference distance between the breakends), orientations
- Cluster by the node or edge based on graph topologies to get candidate subgraphs
- Or walk the graph and look for paths or cycles as candidates
- Summarize a set of features of the candidate subgraphs or walks

## Interactive visualization
We built [`gGnome.js`](https://github.com/mskilab/gGnome.js), an interactive web application that allows browsing the genome graph at arbitrary windows along the reference genome, rich graph annotation options, cohort metadata filtering and more. We have made public the 2778 genome graphs in our paper here so you can start exploring right away.

To visualize your own `gGraph`s and `gWalk`s in the browser, first clone the repo and follow the instructions in its [README](https://github.com/mskilab/gGnome.js/blob/master/README.md). Inside the repo, the graphs are stored as JSON files in the subdirectory `gGnome.js/json/`, with the name `[sample_name].json`. For your own `gGraph` object `gg`, for instance, you can export it into such a JSON file by:

```{r, json, echo = TRUE, eval = FALSE}
gg$json(filename = "gGnome.js/json/[sample_name].json")
```

and start the `Node.js` server by `gGnome.js/start.sh`. If set up correctly you shall see your web browser popping up and you can select the sample in the drop down menu at the top.

More detailed usage of the browser is coming.

## Balancing the graphs
(Under construction...)